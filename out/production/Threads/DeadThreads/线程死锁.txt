    死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，
这些线程会一直互相等待而无法继续运行下去。

    死锁产生必须具备一下条件：
        互斥条件：指线程对已经获取的资源进行排他性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，
则请求者只能等待，直至占用资源的线程释放该资源。

        请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已经被其它线程占有，所以当前线程会被阻塞，
但阻塞额度同时并不释放自己已经获取的资源。

        不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才有自己释放该资源

        环路等待条件：指在发生死锁时，必然存在一个线程————资源的环形链，即线程集合（T0,T1,T2...Tn)中的T0正在等待一个T1占用的资源，
T1正在等待T2占用的资源，....Tn正在等待已经被T0占用的资源。

       Thread[Thread-1,5,main]get ResourceB
       Thread[Thread-0,5,main]get ResourceA
       Thread[Thread-1,5,main]waiting get sourceA
       Thread[Thread-0,5,main]waiting get sourceB

  线程1率先抢到CPU时间片，执行线程1，输出get ResourceB，线程1进入休眠；
  线程0抢到CPU时间片，执行线程0，输出get ResourceA；线程0进入休眠；
  线程1率先结束休眠，请求资源A，此时资源A被线程0掌握，输出waiting get sourceA，等待资源A；
  线程0结束休眠，请求资源B，此时资源B被线程1掌握，输出waiting get sourceB，等待资源B；

    如何避免线程死锁？
    想要避免线程死锁，只需要破坏掉至少以个构造死锁的必要条件即可。目前只有请求并持有和环路等待条件可以破坏。
如DeadLockTest1所示，使得线程和线程1获取资源的顺序一直，便可避免死锁。
